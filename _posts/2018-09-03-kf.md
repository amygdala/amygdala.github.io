---
layout: post
title: "Kubeflow and Machine Learning Workflows"
categories:
- ML
- Kubeflow
tags: cmle cloud_ml tensorflow machine_learning kubeflow kubernetes
date: 2018-09-03
---

## Introduction: Machine Learning Workflows

Model construction and training is just a small part of what you need to pay attention to in order to support ML workflows. For example: porting your data to an accessible format and location; data cleaning and feature engineering; analyzing your trained models; managing model versioning; scalably serving your trained models and avoiding 'training/serving skew; and many other considerations. This is particularly the case when the workflows need to be portable and consistently repeatable, and have many 'moving parts' that need to be integrated. 

Further, most of these activities reoccur across multiple workflows, perhaps just with different parameterizations. Often you're running a set of experiments that need to be performed in an auditable and repeatable manner. 
Sometimes part or all of an ML workflow needs to run on-prem, but in other contexts it may be more productive to use managed cloud services, which make it easy to distribute and scale out the workflow steps, and to run multiple experiments in parallel.

<!--[** consider annotating the argo workflow diagram to show managed vs 'on prem' variants? .. plus the worfklows should be shown up front here, maybe with slightly more readable names, then repeated below **]
-->
<!--[** something re: ML Ops? re: reusability w.r.t building applications. + distribution and parallelization to speed things up **]
-->

<figure>
<a href="https://storage.googleapis.com/amy-jo/images/kf-argo/ml_workflow.png" target="_blank"><img src="https://storage.googleapis.com/amy-jo/images/kf-argo/ml_workflow.png" width="90%"/></a>
<figcaption><br/><i>Model training is just a small part of a typical ML workflow.</i></figcaption>
</figure>

<p></p>


[**Kubeflow**](https://www.kubeflow.org/) is an OSS [**Kubernetes**](https://github.com/kubeflow/kubeflow)-native platform for developing, orchestrating, deploying, and running scalable and portable end-to-end ML workloads.  It helps support reproducibility and collaboration in ML workflow lifecycles, makes it easier to manage end-to-end orchestration of ML-oriented pipelines, and makes it straightforward to run your workflow in multiple or hybrid environments — swapping between on-premises and Cloud building blocks depending upon context — and to reuse building blocks across different workflows. Kubeflow also provides support for visualization and collaboration in your ML workflow.
(You can find other Kubeflow examples [here](https://github.com/kubeflow/examples) as well).


In this article, we'll describe how you can tackle ML workflow operations by using [Kubeflow](https://www.kubeflow.org/) in conjunction with some other services, and point to some [examples](https://github.com/amygdala/code-snippets/tree/master/ml/kubeflow-argo) that you can try yourself.  The examples revolve around a [TensorFlow](https://tensorflow.org) 'taxi fare tip prediction' model, with data pulled from a [public BigQuery dataset of Chicago taxi trips](https://cloud.google.com/bigquery/public-data/chicago-taxi).

We're running the examples on **[Google Kubernetes Engine](https://cloud.google.com/kubernetes-engine/) (GKE)**.
GKE allows easy integration of GCP services that are relevant for ML workflows, including [Dataflow](https://cloud.google.com/dataflow), [BigQuery](https://cloud.google.com/bigquery), and [Cloud ML Engine](https://cloud.google.com/ml-engine).
(If you need to keep your ML workflows on-premises, you may also be interested in [GKE On-Prem](https://cloud.google.com/gke-on-prem/)).

The [examples](https://github.com/amygdala/code-snippets/tree/master/ml/kubeflow-argo) make use of **[TensorFlow Transform](https://github.com/tensorflow/transform) (TFT)** for data preprocessing and to avoid training/serving skew; Kubeflow's [TFJob](https://www.kubeflow.org/docs/guides/components/tftraining/) [CRD](https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/) for supporting distributed training; and **[TensorFlow Model Analysis](https://github.com/tensorflow/model-analysis/) (TFMA)** for analysis of learned models, in conjunction with Kubeflow's [JupyterHub](https://github.com/jupyterhub/jupyterhub) notebooks installation.

The workflows also include deployment of the trained models to both
**[Cloud ML Engine Online Prediction](https://cloud.google.com/ml-engine/docs/tensorflow/prediction-overview)**, 
and to **[TensorFlow Serving](https://github.com/tensorflow/serving)** via Kubeflow.

We'll describe all of these components in more detail below, then show how we can *compose* and reuse these building blocks to create scalable ML workflows that exhibit consistency, reproducibility, and portability.

## Kubeflow components

The [examples](https://github.com/amygdala/code-snippets/tree/master/ml/kubeflow-argo) use [Kubeflow](https://www.kubeflow.org/) with [Argo](https://github.com/argoproj/argo) (a container-native workflow framework for Kubernetes) in order to easily support KF-based ML workflows. These examples highlight how Kubeflow can help support portability, composability, scalability, and reproducibility in your ML lifecycle; and make it easier to support [hybrid](https://cloud.google.com/blog/products/gcp/simplifying-machine-learning-on-open-hybrid-clouds-with-kubeflow) ML solutions. 

Kubeflow's core components include: 

- support for distributed [TensorFlow](https://tensorflow.org) training  via the [TFJob](https://www.kubeflow.org/docs/guides/components/tftraining/) [CRD](https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/);
- serving trained models using [TensorFlow serving](https://github.com/tensorflow/serving);
- and a [JupyterHub](https://github.com/jupyterhub/jupyterhub) installation with many commonly-required libraries and widgets included in the notebook installation, included those needed for [TensorFlow Model Analysis](https://github.com/tensorflow/model-analysis/) (TFMA). 

<figure>
<a href="https://storage.googleapis.com/amy-jo/images/kf-argo/kf_in_the_box.png" target="_blank"><img src="https://storage.googleapis.com/amy-jo/images/kf-argo/kf_in_the_box.png" width="90%"/></a>
<figcaption><br/><i>Kubeflow's current core components focus on the activities highlighted in red.</i></figcaption>
</figure>

<p></p>

We use all of these in our examples, and describe them in more detail below.  
(Kubeflow also includes support for other components not used in our examples).


## TFX building blocks

[TensorFlow Extended (TFX)](https://www.tensorflow.org/tfx/) is a TensorFlow-based general-purpose machine learning platform implemented at Google.
TFX grew out of an [internal project](), and you can find more of an overview [here](https://dl.acm.org/citation.cfm?id=3098021).

TFX components are in the process of being open-sourced, and Kubeflow and our example ML workflows use three of them as building blocks: [TensorFlow Transform](https://github.com/tensorflow/transform), [TensorFlow Model Analysis](https://github.com/tensorflow/model-analysis/), and [TensorFlow serving](https://github.com/tensorflow/serving).

### TensorFlow Transform

**TensorFlow Transform (TFT)** is a library for preprocessing data with TensorFlow. `tf.Transform` is useful for data that requires a full pass of the dataset, such as normalizing an input value by mean and standard deviation; converting a vocabulary to integers by looking at all input examples for values; or categorizing inputs into buckets based on the observed data distribution.

Importantly, its use can also prevent **training-serving skew**, which is a problem that occurs when the feature pre-processing done for training data is not the same as that done for new data prior to prediction. It is easy for this inconsistency to arise when training and serving are managed by different teams, often using different machines or clusters.

However, by using TFT for pre-processing, the output of `tf.Transform` is exported as a *TensorFlow graph* to use for both training and serving, and this TFT graph is exported as part of the trained model graph. This prevents training-serving skew, since the same transformations are applied in both stages. The [example workflows](https://github.com/amygdala/code-snippets/tree/master/ml/kubeflow-argo) **use TFT to support pre-preprocessing**, and this means that after the trained models are deployed for serving and we send a prediction request, the prediction input data is being processed in exactly the same way as was done for training, without the need for any client-side preprocessing framework.

[**Apache Beam**](https://beam.apache.org/) is an OSS framework that lets you implement batch and streaming data processing jobs that run on any execution engine, via a unified programming model for both batch and streaming use cases.
Beam is required to run distributed TFT analysis: essentially, you build Beam pipelines that describe the TFT transformations you want to perform. 
By default, Apache Beam runs in local mode, but can also run in distributed mode using [**Google Cloud Dataflow**](https://cloud.google.com/dataflow), Google Cloud's managed service for running Beam pipelines.  The workflows in [the examples](https://github.com/amygdala/code-snippets/tree/master/ml/kubeflow-argo) use the Beam local runner by default, but can be configured to transparently use Dataflow instead. (For these examples, the default datasets are small, so running locally works fine; but for processing larger datasets, Dataflow lets you automatically scale out your processing across multiple workers).


### TensorFlow Model Analysis (and JupyterHub on Kubeflow)

The second TFX component used in the example workflows is [TensorFlow Model Analysis](https://github.com/tensorflow/model-analysis/) (TFMA).

TFMA is a library for evaluating TensorFlow models. It allows users to evaluate their models on large amounts of data in a distributed manner, using the same metrics defined in their trainer. These metrics can be computed over different slices of data and visualized in Jupyter notebooks.  

<figure>
<a href="https://raw.githubusercontent.com/tensorflow/model-analysis/master/g3doc/images/tfma-slicing-metrics-browser.gif" target="_blank"><img src="https://raw.githubusercontent.com/tensorflow/model-analysis/master/g3doc/images/tfma-slicing-metrics-browser.gif" width="90%"/></a>
<figcaption><br/><i>Visual analysis of TFMA slice results.</i></figcaption>
</figure>

<p></p>

You can compute slices you know you're going to be interested in looking at as part of your main ML workflow, so that the results are ready to examine in a notebook environment.  That's what we do in these example workflows.
Kubflow includes a [JupyterHub](https://github.com/jupyterhub/jupyterhub) installation with the necessary TFMA libraries and widgets installed, and this makes it very straightforward to explore the analysis results in a Kubeflow-supported Jupyter notebook. (Tensorflow Transform libraries are also installed, along with many others).

As with TFT, Apache Beam is required to run distributed analysis; and similarly to TFT, the example workflows support use of the Beam local runner, and can also be run on Dataflow. For the small example datasets, running Beam locally works fine.


### TensorFlow Serving

[TensorFlow Serving](https://github.com/tensorflow/serving) (often abbreviated as "TF-Serving") is another TFX component: an OSS library for serving machine learning models. It deals with the *inference* aspect of machine learning, managing and serving trained models, and can help if you want to serve your TensorFlow models on-prem.  TensorFlow Serving is [a Kubeflow core component](https://www.kubeflow.org/docs/guides/components/tfserving/), which means that it is installed by default when you deploy Kubeflow. [One of the examples](https://github.com/amygdala/code-snippets/tree/master/ml/kubeflow-argo/samples/kubeflow-tf/README.md#example-workflow-1) includes the deployment of trained models to TF-serving, and the example repo includes a client script that can be used to make requests to the deployed TF-serving models.

## Cloud ML Engine Online Prediction

**[Google Cloud ML Engine](https://cloud.google.com/ml-engine/docs/)** is a managed service for training and serving ML models: not only TensorFlow, but scikit-learn and XGBoost as well. 
Cloud ML Engine makes it easy to do distributed training and scalable serving, and provides monitoring, logging, and model and model version management. Cloud ML Engine services can be used as key building blocks for many ML workflows.

For the examples described in this post, since we're highlighting Kubeflow's [TFJob](https://www.kubeflow.org/docs/guides/components/tftraining/), we're not using Cloud ML Engine for training (though we could).
However, we're deploying the trained TensorFlow models to [Cloud ML Engine Online Prediction](https://cloud.google.com/ml-engine/docs/tensorflow/online-predict), which provides scalable serving — say, if you're accessing a model via an app you built, and the app becomes popular, you have no worries about your model serving infrastructure falling over when it gets a barrage of requests.

The workflow deploys the trained models as *versions* of a specific model, in this case named `taxifare`.
Once the model versions are deployed, we can make prediction requests against a specific version.  The [Google Cloud Platform Console](https://console.cloud.google.com) lets you browse through the deployed versions of your different models, set one to be the default, and get information about when each was deployed and last accessed. (In the screenshot below, the rather goofy model version names were generated automatically by our example ML workflow code).

<figure>
<a href="https://storage.googleapis.com/amy-jo/images/kf-argo/cmle_model_versions_.png" target="_blank"><img src="https://storage.googleapis.com/amy-jo/images/kf-argo/cmle_model_versions_.png" width="90%"/></a>
<figcaption><br/><i>Listing versions of a model named 'taxifare' deployed to the Cloud ML Engine Online Prediction service.</i></figcaption>
</figure>

<p></p>

As mentioned above, our workflows use TensorFlow Model Analysis to analyze and compare the learned models, and we can use that information to select the best version as the default — the version served when you make an API request using just the `taxifare` model name. You can set the default version from the GCP Console, or via the [gcloud](https://cloud.google.com/sdk/) tool from the command line.


## Building and Running ML workflows

The building blocks described above can be composed to support common and useful ML workflow patterns. They let us build pipelines that support data ingestion, feature pre-processing, distributed training, evaluation, and serving. Our [examples](https://github.com/amygdala/code-snippets/tree/master/ml/kubeflow-argo) show variants on this basic workflow, and illustrate how easy it is to create these variants via reusable building blocks. 

We're using [Argo](https://github.com/argoproj/argo) (a container-native workflow framework for Kubernetes) for workflow support, and so under the hood, the workflow component definitions use [Docker](https://www.docker.com/) images with parameterizable entry points. This ensures that the workflow components are always **modular** and **portable**.
Many of the workflow components access core Kubeflow components, and some make API calls to Google Cloud Platform managed services (like Cloud ML Engine).

Below, we describe in more detail two example ML workflows built from these components. 

### Running the example workflows

To run the following workflows yourself, see the [README](https://github.com/amygdala/code-snippets/tree/master/ml/kubeflow-argo/README.md), which walks you through the necessary installation steps and describes the code in more detail.

### Example Workflow 1

Our [first example workflow](https://github.com/amygdala/code-snippets/tree/master/ml/kubeflow-argo/samples/kubeflow-tf/README.md#example-workflow-1) illustrates how you can use an ML workflow to experiment with
[TFT](https://github.com/tensorflow/transform)-based feature engineering, and how you can support a hybrid ML flow that serves your trained model from both on-prem and cloud endpoints.

<figure>
<a href="https://storage.googleapis.com/amy-jo/images/kf-argo/argo_workflow1.png" target="_blank"><img src="https://storage.googleapis.com/amy-jo/images/kf-argo/argo_workflow1.png" width="90%"/></a>
<figcaption><br><i>A rendering of a workflow for TFT-based feature engineering experimentation, via the Argo UI.</i></figcaption>
</figure>

<p></p>

The workflow runs two paths concurrently, using a different TFT *preprocessing function* for each path ([`preprocessing.py`](https://github.com/amygdala/code-snippets/tree/master/ml/kubeflow-argo/components/dataflow/tft/preprocessing.py) vs [`preprocessing2.py`](https://github.com/amygdala/code-snippets/tree/master/ml/kubeflow-argo/components/dataflow/tft/preprocessing2.py)). By designing the TFT workflow component to take the preprocessing function definition as an argument, the component is easily reusable across workflows.

Then each model variant is trained, using Kubeflow's [TFJob](https://www.kubeflow.org/docs/guides/components/tftraining/) [CRD](https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/).  For example purposes, **distributed training** is used for one path, leveraging `TFJob`'s easy support for distribution, and single-node training is used for the other.  This distinction is made by specifying the number of *workers* and *parameter servers* to use for the training job. 

Then, the workflow runs runs TFMA analysis on both trained models, so that they can be evaluated and compared, and at the same time deploys the trained models to *both* Cloud ML Engine and TF-Serving. With the use of TFT, the deployed models include the TFT-generated preprocessing graphs, so we don't have to worry about training/serving skew; and by using modular building blocks, it becomes much easier to build such experiments.

This example shows how you can support **hybrid workflows**, where, say, your training runs on-prem (maybe you have some sensitive training data), and then you deploy to both your on-prem TensorFlow Serving cluster and Cloud ML Engine.
It also shows how easy it is to **scale out a Kubeflow TensorFlow training job**, going from a single-node to a large distributed cluster, by just changing the job parameters.

#### Use Kubeflow to visualize model analysis results in a Jupyter notebook

In both of our example workflows, we run TensorFlow Model Analysis (TFMA) on the trained models, using a provided [specification of how to slice the data](https://github.com/amygdala/code-snippets/tree/master/ml/kubeflow-argo/components/dataflow/tfma/model_analysis-taxi.py#L45).  

At any time after this workflow step has been run, the TFMA results can be visualized via a Jupyter notebook, making it easy to assess model quality or compare models.

Kubeflow's [JupyterHub](https://github.com/jupyterhub/jupyterhub) installation makes this easy to do, via a `port-forward` to your Kubernetes Engine cluster. The necessary libraries and visualization widgets are already installed.
If you're playing along, see the *"To connect to your Jupyter Notebook locally"* section in this [Kubeflow guide](https://www.kubeflow.org/docs/guides/components/jupyter/) for more info.
Then load and run the [`tfma_expers.ipynb`](https://github.com/amygdala/code-snippets/tree/master/ml/kubeflow-argo/components/dataflow/tfma/tfma_expers.ipynb) notebook to explore the results of the TFMA analysis.


### Example Workflow 2

The [second example workflow](https://github.com/amygdala/code-snippets/tree/master/ml/kubeflow-argo/samples/kubeflow-tf/README.md#example-workflow-2) shows how you might use TFMA to investigate relative accuracies of models trained on different datasets, evaluating against fresh data. As part of the preprocessing step, it pulls data directly from the source [BigQuery Chicago taxi dataset](https://cloud.google.com/bigquery/public-data/chicago-taxi), with differing min and max time boundaries, effectively training on 'recent' data vs a batch that includes older data.  Then, it runs TFMA analysis on both learned models, using the newest data for evaluation.  It also evaluates the 'recent' data against an older model trained on older data.

As with `Workflow 1` above, the trained models are deployed to Cloud ML Engine, where the most accurate ones can be selected to use for prediction.


<figure>
<a href="https://storage.googleapis.com/amy-jo/images/kf-argo/argo_workflow2.png" target="_blank"><img src="https://storage.googleapis.com/amy-jo/images/kf-argo/argo_workflow2.png" width="90%"/></a>
<figcaption><br/><i>Comparing models trained on datasets that cover differing time intervals.</i></figcaption>
</figure>

<p></p>

So, this example shows how you can define workflows to support consistent model regeneration and re-evaluation over sliding time windows of data, to determine whether the characteristics of new prediction data have changed.  
(While not shown as part of this example, a similar workflow could also be used to support incremental training of an existing model on successive new datasets, and comparison of that model with new models trained 'from scratch').

    
### Use your models for prediction with Cloud ML Engine Online Prediction

As part of both workflows, the trained models were deployed to Cloud ML Engine Online Prediction. The model name
is `taxifare`, and the version names are derived from the workflow names.

You can view the deployed versions of the `taxifare` model in the [GCP Console](https://console.cloud.google.com/mlengine/models).

If you're playing along, it is easy to **make a prediction using one of the deployed Cloud ML Engine model versions**.  Change to the [`components/cmle`](https://github.com/amygdala/code-snippets/tree/master/ml/kubeflow-argo/components/cmle) directory of your repo checkout to find the `temp_input2.json` example input, and run the following command, replacing `<YOUR_PROJECT_NAME>` and `<MODEL_VERSION_NAME>`.

```sh
gcloud ml-engine predict --model=taxifare --json-instances=temp_input2.json --project=<YOUR_PROJECT_NAME> \
 --version=<MODEL_VERSION_NAME>
```

(This command requires that you have the [`gcloud` sdk installed](https://cloud.google.com/sdk/install); or as described in the [README](https://github.com/amygdala/code-snippets/tree/master/ml/kubeflow-argo/README.md), you can use your project's [Cloud Shell](https://cloud.google.com/shell/docs/) instead).  
You can set any of your model versions to be the *default*. For the default model, the request does not need to include the `--version` arg.

### Make predictions using TF-Serving endpoints

The first example workflow deployed the trained models not only to Cloud ML Engine, but also to [TensorFlow Serving](https://github.com/tensorflow/serving), which is part  of the Kubeflow installation.

To make it easy to demo, the TF-serving deployments use a Kubernetes service of type `LoadBalancer`, which creates an endpoint with an external IP. (For a production system, you'd probably want to use something like [Cloud Identity-Aware Proxy](https://cloud.google.com/iap/)).

If you're playing along, you can view the TF-Serving endpoint services created by the workflow by running:

```sh
kubectl get services
```
from the command line.
For this particular workflow, look for the services with prefix `preproc-train-deploy2-analyze` (the workflow prefix), and note their names and external IP addresses. 

It is easy to **make requests to the TensorFlow Serving endpoints** using a client script — find an example script and more detail in [the README](https://github.com/amygdala/code-snippets/tree/master/ml/kubeflow-argo#access-the-tf-serving-endpoints-for-your-learned-model).

Should you want to scale a TF-Serving endpoint to handle a large number of requests, this is easy to do via Kubernetes' underlying capabilities: scale the [Deployment](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/) backing the endpoint service. 


## Learn more, and join the Kubeflow community

We hope these examples encouraged you to [download](https://github.com/kubeflow/kubeflow/releases) and try Kubeflow yourself (please submit bugs and tell us what features you'd like to see!), and even become a contributor.

Here are some resources for learning more and getting help:

- The [Kubeflow Slack channel](https://join.slack.com/t/kubeflow/shared_invite/enQtMjgyMzMxNDgyMTQ5LWUwMTIxNmZlZTk2NGU0MmFiNDE4YWJiMzFiOGNkZGZjZmRlNTExNmUwMmQ2NzMwYzk5YzQxOWQyODBlZGY2OTg)
- [More Kubeflow examples](https://github.com/kubeflow/examples)
- The [Kubeflow-discuss email list](https://groups.google.com/forum/#!forum/kubeflow-discuss)
- The [Kubeflow Twitter account](http://twitter.com/kubeflow)
- Our [weekly community meeting](https://github.com/kubeflow/community)
